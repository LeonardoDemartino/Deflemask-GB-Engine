//by Pegmode

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
//CONSTANTS
//===========================================================
#define DEFLEMASK_DATA_START 0xC0
#define VGM_SAMPLE_RATE 44100//this is rate that a vgm file samples the registers
#define GB_BANK_SIZE 0x3FFF//~16kb per bank
//vgm commands
#define WRITEVGMCOMMAND 0xB3
#define WAITSTDVGMCOMMAND 0x62 //wait for a single engine frame (1/60s)
#define WAITVGMCOMMAND 0x61 //wait for xy vgm frames (1/VGM_SAMPLE_RATE)
#define ENDVGMCOMMAND 0x66
#define DATABLOCKVGMCOMMAND 0x67
//custom GB engine commands
#define WRITECUSCOMMAND 0x80//7th bit 
#define WAITCUSCOMMAND 0x40
#define NEXTBANKCUSCOMMAND 0x20
#define LOOPCUSCOMMAND 0x10
#define ENDSONGCUSCOMMAND 0x08
//ENGINE VARS
//===========================================================
#define DATA_START_BANK 0x01
#define DEFAULT_SYNC_HIGH_ADDRESS 0xFA//change this to change where the sync signal writes to 
#define MAX_DATABANKS 0xFF//must be less than or equal to what the asm engine is designed to handle and never greater than 0xFF


struct VgmBuffer{//contains vgm info and file buffer for Deflemask generated GB Vgm
    uint8_t* buffer;
    int size;
    uint8_t rate;
};
typedef struct VgmBuffer VgmBuffer;

//CODE
//===========================================================

uint8_t vgmToGBTL(uint8_t value){//translate vgm write command destination address to actual FFxy value
    return value + 0x10;
}

void openFile(char* path,VgmBuffer* vgmBuffer){
    FILE *f;
    f = fopen(path,"rb");
    fseek(f,0,SEEK_END);
    int fileSize = ftell(f);
    vgmBuffer->buffer = malloc(fileSize);
    fseek(f,0,SEEK_SET);
    fread(vgmBuffer->buffer,1,fileSize,f);
    fclose(f);
    vgmBuffer->size = fileSize;
}

void checkHeader(VgmBuffer vgmBuffer){
    //test Header

    if (memcmp(vgmBuffer.buffer,"Vgm",3) != 0){
        printf(".vgm header fail\n");
        exit(0);
    }
    //check gb
    uint8_t gbEmptyVal = 0;
    if (memcmp(&vgmBuffer.buffer[0x80],&gbEmptyVal,4) == 0){
        printf(".vgm does not use Game Boy\n");
        exit(0);
    }
}

int checkIfBankEnd(int currentOutputPos,int distance){//check if a given write operation to the output buffer will fall outside a Game Boy ROM bank
    if((currentOutputPos + distance + 1) > GB_BANK_SIZE){//add 1 so we make sure we have room for bank
        return 1;
    }
    else{
        return 0;
    }
}

int samplesToFrames(int engineRate,int samples){//calculate the number of frames based on number of samples
    return (int)(((float)samples / (float)VGM_SAMPLE_RATE) / (1 / (float)engineRate));
}


void printBuffer(uint8_t* buffer,int size){//rate 44100
    for(int i = 0;i < size;i++){
        if (i % 0xF == 0){
            printf("\n%X: ",i);
        }
        printf("%X ",buffer[i]);
    }
}

void checkVgmIsDeflemask(VgmBuffer vgmBuffer){
    uint8_t deflemaskFooter[] = {0x44, 0x00, 0x65, 0x00, 0x66, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,};
    uint8_t footerBuffer[0x26];
    memcpy(footerBuffer,&vgmBuffer.buffer[vgmBuffer.size-0x26],0x26);
    if(memcmp(deflemaskFooter,footerBuffer,0x26) != 0){
        printf("vgm was not Generated by Deflemask. Only Deflemask .vgms are supported.");
        exit(1);
    }
}

void writeAllBanks(uint8_t** banks,int numBanks){
    char outputName[0xFF];
    for(int i = 0; i <= numBanks; i++){
        sprintf(outputName,"songBank%u.bin",i);
        FILE *f = fopen(outputName,"wb");
        fwrite(banks[i],1,GB_BANK_SIZE,f);
        fclose(f);
    }
}

void convertToNewFormat(VgmBuffer vgmBuffer){
    int currentVgmPos = DEFLEMASK_DATA_START;
    int currentBank = 0;//NOT TRUE BANK, is position in output array
    int currentOutputPos = 0;
    int notEndOfFile = 1;
    uint8_t* output[0xFF];//array of banks
    while(notEndOfFile){//we don't know how many banks the output will take up ahead of time
        //create new block
            //while in block parse until we hit the maxsize
            //create new ,
        uint8_t* currentBankBuffer = malloc(GB_BANK_SIZE);
        memset(currentBankBuffer,0,GB_BANK_SIZE);
        currentOutputPos = 0;
        int notEndOfBank = 1 ;
        while(notEndOfBank){
            switch(vgmBuffer.buffer[currentVgmPos]){
                case WRITEVGMCOMMAND://write to 0xFFXX
                    if (checkIfBankEnd(currentOutputPos,3)){
                        printf("moving to next back in WRITE\n");
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        currentBankBuffer[currentOutputPos] = WRITECUSCOMMAND;//write new command
                        currentVgmPos++;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmToGBTL(vgmBuffer.buffer[currentVgmPos]);//write address
                        currentVgmPos++;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmBuffer.buffer[currentVgmPos];//write value
                        currentVgmPos++;
                        currentOutputPos++;
                    }                                       
                    break;
                case WAITVGMCOMMAND://wait for XX frames
                    if (checkIfBankEnd(currentOutputPos,2)){
                        printf("moving to next back in Wait\n");
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        //be careful: calculate frames from number of samples
                        currentBankBuffer[currentOutputPos] = WAITCUSCOMMAND;//write new command
                        currentOutputPos++;
                        currentVgmPos++;
                        int highV = (int)vgmBuffer.buffer[currentVgmPos];
                        currentVgmPos++;
                        int lowV = (int)vgmBuffer.buffer[currentVgmPos];
                        int numberOfSamples = (lowV << 8) | highV;//mask 16bit 
                        int numberOfFrames = samplesToFrames(60,numberOfSamples);//change 60 to be scanned value later
                        currentBankBuffer[currentOutputPos] = numberOfFrames;
                        currentVgmPos++;
                        currentOutputPos++; 
                    }
                    break;
                case WAITSTDVGMCOMMAND://wait for 1 frame in 60hz engine rate
                    if (checkIfBankEnd(currentOutputPos,1)){
                        printf("moving to next back in SWait\n");
                        notEndOfBank = 0;   
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND; 
                    }
                    else{
                        currentBankBuffer[currentOutputPos] = WAITCUSCOMMAND;//write new command
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = 1;
                        currentVgmPos++;
                        currentOutputPos++;
                    }
                    break;

                case DATABLOCKVGMCOMMAND://write data to 0xFF<SYNC_ADDRESS> +=9
                    if (checkIfBankEnd(currentOutputPos,2)){
                        printf("moving to next back in Datablock\n");
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        currentVgmPos += 9;//jump to data block value
                        currentBankBuffer[currentOutputPos] = WRITECUSCOMMAND;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmBuffer.buffer[currentVgmPos];
                        currentVgmPos++;
                        currentOutputPos++;
                    }
                    break;
                case ENDVGMCOMMAND://end the song
                    printf("VGM end found!\n");
                    currentBankBuffer[currentOutputPos] = ENDSONGCUSCOMMAND;//write new command
                    currentOutputPos++;
                    notEndOfBank = 0;
                    notEndOfFile = 0;
                    break;
                default:
                    printf("Error while parsing vgm commands, incorrect command found\n");
                    exit(1);
            }
        }
    output[currentBank] = currentBankBuffer;
    if (notEndOfFile){
        currentBank++;
    }
    }
    writeAllBanks(output,currentBank);
    printf("Conversion Complete!\n%u banks used\n",currentBank+1);
}



int main(int argc, char* argv[]){
    if (argc < 2){
        printf("Must give a .vgm as argument to program\n");
        exit(1);
    }
    printf("RUNNING\n");
    VgmBuffer vgmBuffer;
    printf("OPENING .vgm\n");    
    openFile(argv[1],&vgmBuffer);
    printf("OPENED\n");
    checkHeader(vgmBuffer);
    printf("Header Check passed!\n");
    checkVgmIsDeflemask(vgmBuffer);
    printf("Deflemask Footer check passed!\n");
    convertToNewFormat(vgmBuffer);
    free(vgmBuffer.buffer);
    return 0;
}