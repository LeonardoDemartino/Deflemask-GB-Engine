//by Pegmode

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>
//CONSTANTS
//===========================================================
#define DEFLEMASK_DATA_START 0xC0
#define VGM_SAMPLE_RATE 44100//this is rate that a vgm file samples the registers
#define GB_BANK_SIZE 0x3FFF//~16kb per bank
#define TMA_RATE 4096//00 rate (4096hz)
//vgm commands
#define WRITEVGMCOMMAND 0xB3
#define WAITSTDVGMCOMMAND 0x62 //wait for a single engine frame (1/60s)
#define WAITVGMCOMMAND 0x61 //wait for xy vgm frames (1/VGM_SAMPLE_RATE)
#define ENDVGMCOMMAND 0x66
#define DATABLOCKVGMCOMMAND 0x67
//custom GB engine commands
#define WRITECUSCOMMAND 0x80//7th bit 
#define WAITCUSCOMMAND 0x40
#define NEXTBANKCUSCOMMAND 0x20
#define LOOPCUSCOMMAND 0x10
#define ENDSONGCUSCOMMAND 0x08
//ENGINE VARS
//===========================================================
#define DATA_START_BANK 0x01
#define DEFAULT_SYNC_HIGH_ADDRESS 0x80//change this to change where the sync signal writes to 
#define MAX_DATABANKS 0xFF//must be less than or equal to what the asm engine is designed to handle and never greater than 0xFF


struct VgmBuffer{//contains vgm info and file buffer for Deflemask generated GB Vgm
    uint8_t* buffer;
    int size;
    uint8_t rate;
};
typedef struct VgmBuffer VgmBuffer;
//Globals
//===========================================================
int EXPORTMODE = 0;//0 = patch .gb
int ENGINE_RATE = 60;//default rate to 60hz
char OUTPATH[0xFF] = "output";
char* PATCHROM_PATH = "patchROM.gb";
int TMA_OFFSET = 0;//value to add to TMA for fine control

char* HELPSTRING = "\nHelp:\n DeflemaskGBGMConverter <input vgm> [args...]\n\
\nargs:\n\
-r <rate> set engine rate\n\
-o <outpath> set the output path\n\
-bin export as .bin file instead of patching .gb\n\
-ti <offset> increase tma offset timing (speed up song if using custom engine speed)\n\
-td <offset> decrease tma offset timing (slow down song if using custom engine speed)\n";

//CODE
//===========================================================

uint8_t vgmToGBTL(uint8_t value){//translate vgm write command destination address to actual FFxy value
    return value + 0x10;
}

void openFile(char* path,VgmBuffer* vgmBuffer){
    FILE *f;
    f = fopen(path,"rb");
    fseek(f,0,SEEK_END);
    int fileSize = ftell(f);
    vgmBuffer->buffer = malloc(fileSize);
    fseek(f,0,SEEK_SET);
    fread(vgmBuffer->buffer,1,fileSize,f);
    fclose(f);
    vgmBuffer->size = fileSize;
}

void checkHeader(VgmBuffer vgmBuffer){
    //test Header

    if (memcmp(vgmBuffer.buffer,"Vgm",3) != 0){
        printf(".vgm header fail\n");
        exit(0);
    }
    //check gb
    uint8_t gbEmptyVal = 0;
    if (memcmp(&vgmBuffer.buffer[0x80],&gbEmptyVal,4) == 0){
        printf(".vgm does not use Game Boy\n");
        exit(0);
    }
}

int checkIfBankEnd(int currentOutputPos,int distance){//check if a given write operation to the output buffer will fall outside a Game Boy ROM bank
    if((currentOutputPos + distance + 1) > GB_BANK_SIZE){//add 1 so we make sure we have room for bank
        return 1;
    }
    else{
        return 0;
    }
}

int samplesToFrames(int engineRate,int samples){//calculate the number of frames based on number of samples
    float frameCount = ((float)samples / (float)VGM_SAMPLE_RATE) / (1 / (float)engineRate);
    //printf("frameCount: %u\nengineRate: %u\nsamples: %u\n",frameCount,engineRate,samples);
    if (frameCount != (int)frameCount){
        double whole;
        float fractional = modf(frameCount, &whole);
        if (fractional < 0.99){
            printf("ERROR: Frame calculation failure. Engine tick rate of %uhz is likely incorrect. Use -r argumment to change engine rate\n",ENGINE_RATE);
            exit(1);
        }
        whole++;
        frameCount = whole;
    }
    return (int)frameCount;
}

int calculateTMAModulo(){//calculate the modulo value to use
    float floatDistance = (float)TMA_RATE/(float)ENGINE_RATE;
    double whole;
    float fract;
    fract = modf(floatDistance,&whole);
    if (fract >= 0.5){
        whole++;
    }
    return 0xFF-(int)whole;
}


void printBuffer(uint8_t* buffer,int size){//rate 44100
    for(int i = 0;i < size;i++){
        if (i % 0xF == 0){
            printf("\n%X: ",i);
        }
        printf("%X ",buffer[i]);
    }
}

void checkVgmIsDeflemask(VgmBuffer vgmBuffer){
    uint8_t deflemaskFooter[] = {0x44, 0x00, 0x65, 0x00, 0x66, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x63, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,};
    uint8_t footerBuffer[0x26];
    memcpy(footerBuffer,&vgmBuffer.buffer[vgmBuffer.size-0x26],0x26);
    if(memcmp(deflemaskFooter,footerBuffer,0x26) != 0){
        printf("vgm was not Generated by Deflemask. Only Deflemask .vgms are supported.");
        exit(1);
    }
}

void writeAllBanks(uint8_t** banks,int numBanks){
    char outputName[0xFF];
    for(int i = 0; i <= numBanks; i++){
        sprintf(outputName,"%s%u.bin",OUTPATH,i);
        FILE *f = fopen(outputName,"wb");
        fwrite(banks[i],1,GB_BANK_SIZE,f);
        fclose(f);
    }
}

void patchROM(uint8_t** banks,int numBanks){
    //load patch ROM into buffer
    FILE* f;
    f = fopen(PATCHROM_PATH,"rb");
    fseek(f,0,SEEK_END);
    int fileSize = ftell(f);
    uint8_t* patchBuffer = malloc(fileSize + (numBanks + 1) * 0x4000);
    fseek(f,0,SEEK_SET);
    fread(patchBuffer,1,fileSize,f);
    fclose(f);
    //copy bank buffer 
    for (int i = 0; i < numBanks+1; i++){
        printf("patching bank %u, at address 0x%X\n",i+1,0x4000+i*0x4000);
        memcpy(&patchBuffer[0x4000+i*0x4000],banks[i],0x3FFF);
    }
    // write TMA
    int tmaDistance = 0;
    if (ENGINE_RATE != 60){
        tmaDistance = calculateTMAModulo();
        patchBuffer[0x02] = 4;
    }
    else{
        patchBuffer[0x02] = 0;
    }
    patchBuffer[0x01] = tmaDistance + TMA_OFFSET;

    char outROMPath[0xFF];
    sprintf(outROMPath,"%s.gb",OUTPATH);
    f = fopen(outROMPath,"wb");
    printf("Output Size: %ubytes\n",0x4000 * (fileSize + 1));
    int outputSize = fileSize + 0x4000 * (numBanks + 1);
    fwrite(patchBuffer,1,outputSize,f);
    fclose(f);
    free(patchBuffer);

}

void convertToNewFormat(VgmBuffer vgmBuffer){
    int currentVgmPos = DEFLEMASK_DATA_START;
    int currentBank = 0;//NOT TRUE BANK, is position in output array
    int currentOutputPos = 0;
    int notEndOfFile = 1;
    uint8_t* output[0xFF];//array of banks
    while(notEndOfFile){//we don't know how many banks the output will take up ahead of time
        //create new block
            //while in block parse until we hit the maxsize
            //create new ,
        uint8_t* currentBankBuffer = malloc(GB_BANK_SIZE);
        memset(currentBankBuffer,0,GB_BANK_SIZE);
        currentOutputPos = 0;
        int notEndOfBank = 1 ;
        while(notEndOfBank){
            switch(vgmBuffer.buffer[currentVgmPos]){
                case WRITEVGMCOMMAND://write to 0xFFXX
                    if (checkIfBankEnd(currentOutputPos,3)){
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        currentBankBuffer[currentOutputPos] = WRITECUSCOMMAND;//write new command
                        currentVgmPos++;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmToGBTL(vgmBuffer.buffer[currentVgmPos]);//write address
                        currentVgmPos++;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmBuffer.buffer[currentVgmPos];//write value
                        currentVgmPos++;
                        currentOutputPos++;
                    }                                       
                    break;
                case WAITVGMCOMMAND://wait for XX frames
                    if (checkIfBankEnd(currentOutputPos,2)){
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        //be careful: calculate frames from number of samples
                        currentBankBuffer[currentOutputPos] = WAITCUSCOMMAND;//write new command
                        currentOutputPos++;
                        currentVgmPos++;
                        int highV = (int)vgmBuffer.buffer[currentVgmPos];
                        currentVgmPos++;
                        int lowV = (int)vgmBuffer.buffer[currentVgmPos];
                        int numberOfSamples = (lowV << 8) | highV;//mask 16bit 
                        int numberOfFrames = samplesToFrames(ENGINE_RATE,numberOfSamples);//change 60 to be scanned value later
                        currentBankBuffer[currentOutputPos] = numberOfFrames;
                        currentVgmPos++;
                        currentOutputPos++; 
                    }
                    break;
                case WAITSTDVGMCOMMAND://wait for 1 frame in 60hz engine rate
                    if (checkIfBankEnd(currentOutputPos,1)){
                        notEndOfBank = 0;   
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND; 
                    }
                    else{
                        currentBankBuffer[currentOutputPos] = WAITCUSCOMMAND;//write new command
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = 1;
                        currentVgmPos++;
                        currentOutputPos++;
                    }
                    break;

                case DATABLOCKVGMCOMMAND://write data to 0xFF<SYNC_ADDRESS> +=9
                    if (checkIfBankEnd(currentOutputPos,3)){
                        notEndOfBank = 0;    
                        currentBankBuffer[currentOutputPos] = NEXTBANKCUSCOMMAND;
                    }
                    else{
                        currentVgmPos += 9;//jump to data block value
                        currentBankBuffer[currentOutputPos] = WRITECUSCOMMAND;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = DEFAULT_SYNC_HIGH_ADDRESS;
                        currentOutputPos++;
                        currentBankBuffer[currentOutputPos] = vgmBuffer.buffer[currentVgmPos];
                        currentVgmPos++;
                        currentOutputPos++;
                    }
                    break;
                case ENDVGMCOMMAND://end the song
                    printf("VGM end found!\n");
                    currentBankBuffer[currentOutputPos] = ENDSONGCUSCOMMAND;//write new command
                    currentOutputPos++;
                    notEndOfBank = 0;
                    notEndOfFile = 0;
                    break;
                default:
                    printf("Error while parsing vgm commands, incorrect command found\n");
                    exit(1);
            }
        }
    output[currentBank] = currentBankBuffer;
    if (notEndOfFile){
        currentBank++;
    }
    }

    
    if (EXPORTMODE){//if asm export mode was enabled
        if (ENGINE_RATE != 60){
            int tmaDistance = calculateTMAModulo();
            printf("Non-vBlank Engine speed found, set TMA to = 0x%X\n",tmaDistance);
        }
        writeAllBanks(output,currentBank);       
    }
    else{
        patchROM(output,currentBank);
    }

    printf("Conversion Complete!\n%u banks used\n",currentBank+1);
}

void parseArgs(int argc, char** argv){
    if (argc < 2){
        printf("Must give a .vgm as argument to program\n");
        printf("%s",HELPSTRING);
        exit(1);
    }
    for (int i = 2; i < argc; i++){
        if(strcmp("-r",argv[i]) == 0){//rate
            i++;
            ENGINE_RATE = atoi(argv[i]);
            printf("Engine rate set to %u\n"),ENGINE_RATE;
        }
        else if(strcmp("-o",argv[i]) == 0){//output path
            i++;
            strcpy(OUTPATH,argv[i]);
        }
        else if(strcmp("-h",argv[i]) == 0){//help
            printf("%s",HELPSTRING);
            exit(1);
        }
        else if(strcmp("-bin",argv[i]) == 0){//
            EXPORTMODE = 1;
        }
        else if(strcmp("-td",argv[i]) == 0){//tma decrease
            TMA_OFFSET = -atoi(argv[++i]);
        }
        else if(strcmp("-ti",argv[i]) == 0){//tma increase
            TMA_OFFSET = atoi(argv[++i]);
        }
    }   

}

int main(int argc, char* argv[]){
    parseArgs(argc,argv);
    printf("RUNNING\n");
    VgmBuffer vgmBuffer;
    printf("OPENING .vgm\n");    
    openFile(argv[1],&vgmBuffer);
    printf("OPENED\n");
    checkHeader(vgmBuffer);
    printf("Header Check passed!\n");
    checkVgmIsDeflemask(vgmBuffer);
    printf("Deflemask Footer check passed!\n");
    convertToNewFormat(vgmBuffer);
    free(vgmBuffer.buffer);
    return 0;
}